<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMD Processor - SETR: Unity Assertions Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CMD Processor - SETR<span id="projectnumber">&#160;1.2</span>
   </div>
   <div id="projectbrief">Second Project for the SETR class of 2024-2025 at Universidade of Aveiro</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_src_2Unity_2docs_2UnityAssertionsReference.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Unity Assertions Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md49"></a></p>
<h1><a class="anchor" id="autotoc_md50"></a>
Background and Overview</h1>
<h2><a class="anchor" id="autotoc_md51"></a>
Super Condensed Version</h2>
<ul>
<li>An assertion establishes truth (i.e. boolean True) for a single condition. Upon boolean False, an assertion stops execution and reports the failure.</li>
<li>Unity is mainly a rich collection of assertions and the support to gather up and easily execute those assertions.</li>
<li>The structure of Unity allows you to easily separate test assertions from source code in, well, test code.</li>
<li>Unity’s assertions:<ul>
<li>Come in many, many flavors to handle different C types and assertion cases.</li>
<li>Use context to provide detailed and helpful failure messages.</li>
<li>Document types, expected values, and basic behavior in your source code for free.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md52"></a>
Unity Is Several Things But Mainly It’s Assertions</h2>
<p>One way to think of Unity is simply as a rich collection of assertions you can use to establish whether your source code behaves the way you think it does. Unity provides a framework to easily organize and execute those assertions in test code separate from your source code.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
What’s an Assertion?</h2>
<p>At their core, assertions are an establishment of truth - boolean truth. Was this thing equal to that thing? Does that code doohickey have such-and-such property or not? You get the idea. Assertions are executable code. Static analysis is a valuable approach to improving code quality, but it is not executing your code in the way an assertion can. A failing assertion stops execution and reports an error through some appropriate I/O channel (e.g. stdout, GUI, output file, blinky light).</p>
<p>Fundamentally, for dynamic verification all you need is a single assertion mechanism. In fact, that’s what the <a href="http://en.wikipedia.org/wiki/Assert.h">assert() macro</a> in C’s standard library is for. So why not just use it? Well, we can do far better in the reporting department. C’s <code>assert()</code> is pretty dumb as-is and is particularly poor for handling common data types like arrays, structs, etc. And, without some other support, it’s far too tempting to litter source code with C’s <code>assert()</code>’s. It’s generally much cleaner, manageable, and more useful to separate test and source code in the way Unity facilitates.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
Unity’s Assertions: Helpful Messages <em>and</em> Free Source Code Documentation</h2>
<p>Asserting a simple truth condition is valuable, but using the context of the assertion is even more valuable. For instance, if you know you’re comparing bit flags and not just integers, then why not use that context to give explicit, readable, bit-level feedback when an assertion fails?</p>
<p>That’s what Unity’s collection of assertions do - capture context to give you helpful, meaningful assertion failure messages. In fact, the assertions themselves also serve as executable documentation about types and values in your source code. So long as your tests remain current with your source and all those tests pass, you have a detailed, up-to-date view of the intent and mechanisms in your source code. And due to a wondrous mystery, well-tested code usually tends to be well designed code.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Assertion Conventions and Configurations</h1>
<h2><a class="anchor" id="autotoc_md56"></a>
Naming and Parameter Conventions</h2>
<p>The convention of assertion parameters generally follows this order:</p>
<div class="fragment"><div class="line">TEST_ASSERT_X( {modifiers}, {expected}, actual, {size/count} )</div>
</div><!-- fragment --><p>The very simplest assertion possible uses only a single <code>actual</code> parameter (e.g. a simple null check).</p>
<ul>
<li><code>Actual</code> is the value being tested and unlike the other parameters in an assertion construction is the only parameter present in all assertion variants.</li>
<li><code>Modifiers</code> are masks, ranges, bit flag specifiers, floating point deltas.</li>
<li><code>Expected</code> is your expected value (duh) to compare to an <code>actual</code> value; it’s marked as an optional parameter because some assertions only need a single <code>actual</code> parameter (e.g. null check).</li>
<li><code>Size/count</code> refers to string lengths, number of array elements, etc.</li>
</ul>
<p>Many of Unity’s assertions are clear duplications in that the same data type is handled by several assertions. The differences among these are in how failure messages are presented. For instance, a <code>_HEX</code> variant of an assertion prints the expected and actual values of that assertion formatted as hexadecimal.</p>
<h3><a class="anchor" id="autotoc_md57"></a>
TEST_ASSERT_X_MESSAGE Variants</h3>
<p><em>All</em> assertions are complemented with a variant that includes a simple string message as a final parameter. The string you specify is appended to an assertion failure message in Unity output.</p>
<p>For brevity, the assertion variants with a message parameter are not listed below. Just tack on <code>_MESSAGE</code> as the final component to any assertion name in the reference list below and add a string as the final parameter.</p>
<p><em>Example:</em></p>
<div class="fragment"><div class="line">TEST_ASSERT_X( {modifiers}, {expected}, actual, {size/count} )</div>
</div><!-- fragment --><p>becomes messageified like thus…</p>
<div class="fragment"><div class="line">TEST_ASSERT_X_MESSAGE( {modifiers}, {expected}, actual, {size/count}, message )</div>
</div><!-- fragment --><p>Notes:</p>
<ul>
<li>The <code>_MESSAGE</code> variants intentionally do not support <code>printf</code> style formatting since many embedded projects don’t support or avoid <code>printf</code> for various reasons. It is possible to use <code>sprintf</code> before the assertion to assemble a complex fail message, if necessary.</li>
<li>If you want to output a counter value within an assertion fail message (e.g. from a loop) , building up an array of results and then using one of the <code>_ARRAY</code> assertions (see below) might be a handy alternative to <code>sprintf</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md58"></a>
TEST_ASSERT_X_ARRAY Variants</h3>
<p>Unity provides a collection of assertions for arrays containing a variety of types. These are documented in the Array section below. These are almost on par with the <code>_MESSAGE</code>variants of Unity’s Asserts in that for pretty much any Unity type assertion you can tack on <code>_ARRAY</code> and run assertions on an entire block of memory.</p>
<div class="fragment"><div class="line">TEST_ASSERT_EQUAL_TYPEX_ARRAY( expected, actual, {size/count} )</div>
</div><!-- fragment --><ul>
<li><code>Expected</code> is an array itself.</li>
<li><code>Size/count</code> is one or two parameters necessary to establish the number of array elements and perhaps the length of elements within the array.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The <code>_MESSAGE</code> variant convention still applies here to array assertions. The <code>_MESSAGE</code> variants of the <code>_ARRAY</code> assertions have names ending with <code>_ARRAY_MESSAGE</code>.</li>
<li>Assertions for handling arrays of floating point values are grouped with float and double assertions (see immediately following section).</li>
</ul>
<h2><a class="anchor" id="autotoc_md59"></a>
TEST_ASSERT_EACH_EQUAL_X Variants</h2>
<p>Unity provides a collection of assertions for arrays containing a variety of types which can be compared to a single value as well. These are documented in the Each Equal section below. these are almost on par with the <code>_MESSAGE</code> variants of Unity’s Asserts in that for pretty much any Unity type assertion you can inject <code>_EACH_EQUAL</code> and run assertions on an entire block of memory.</p>
<div class="fragment"><div class="line">TEST_ASSERT_EACH_EQUAL_TYPEX( expected, actual, {size/count} )</div>
</div><!-- fragment --><ul>
<li><code>Expected</code> is a single value to compare to.</li>
<li><code>Actual</code> is an array where each element will be compared to the expected value.</li>
<li><code>Size/count</code> is one of two parameters necessary to establish the number of array elements and perhaps the length of elements within the array.</li>
</ul>
<p>Notes:</p>
<ul>
<li>The <code>_MESSAGE</code> variant convention still applies here to Each Equal assertions.</li>
<li>Assertions for handling Each Equal of floating point values are grouped with float and double assertions (see immediately following section).</li>
</ul>
<h2><a class="anchor" id="autotoc_md60"></a>
Configuration</h2>
<h3><a class="anchor" id="autotoc_md61"></a>
Floating Point Support Is Optional</h3>
<p>Support for floating point types is configurable. That is, by defining the appropriate preprocessor symbols, floats and doubles can be individually enabled or disabled in Unity code. This is useful for embedded targets with no floating point math support (i.e. Unity compiles free of errors for fixed point only platforms). See Unity documentation for specifics.</p>
<h3><a class="anchor" id="autotoc_md62"></a>
Maximum Data Type Width Is Configurable</h3>
<p>Not all targets support 64 bit wide types or even 32 bit wide types. Define the appropriate preprocessor symbols and Unity will omit all operations from compilation that exceed the maximum width of your target. See Unity documentation for specifics.</p>
<h1><a class="anchor" id="autotoc_md63"></a>
The Assertions in All Their Blessed Glory</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
Basic Fail, Pass and Ignore</h2>
<h3><a class="anchor" id="autotoc_md65"></a>
<code>TEST_FAIL()</code></h3>
<h3><a class="anchor" id="autotoc_md66"></a>
<code>TEST_FAIL_MESSAGE("message")</code></h3>
<p>This fella is most often used in special conditions where your test code is performing logic beyond a simple assertion. That is, in practice, <code><a class="el" href="unity_8h.html#acf4d2a6eb579e0c4d02cd64c8f350aa2">TEST_FAIL()</a></code> will always be found inside a conditional code block.</p>
<p><em>Examples:</em></p>
<ul>
<li>Executing a state machine multiple times that increments a counter your test code then verifies as a final step.</li>
<li>Triggering an exception and verifying it (as in Try / Catch / Throw - see the <a href="https://github.com/ThrowTheSwitch/CException">CException</a> project).</li>
</ul>
<h3><a class="anchor" id="autotoc_md67"></a>
<code>TEST_PASS()</code></h3>
<h3><a class="anchor" id="autotoc_md68"></a>
<code>TEST_PASS_MESSAGE("message")</code></h3>
<p>This will abort the remainder of the test, but count the test as a pass. Under normal circumstances, it is not necessary to include this macro in your tests… a lack of failure will automatically be counted as a <code>PASS</code>. It is occasionally useful for tests with <code>#ifdef</code>s and such.</p>
<h3><a class="anchor" id="autotoc_md69"></a>
<code>TEST_IGNORE()</code></h3>
<h3><a class="anchor" id="autotoc_md70"></a>
<code>TEST_IGNORE_MESSAGE("message")</code></h3>
<p>Marks a test case (i.e. function meant to contain test assertions) as ignored. Usually this is employed as a breadcrumb to come back and implement a test case. An ignored test case has effects if other assertions are in the enclosing test case (see Unity documentation for more).</p>
<h3><a class="anchor" id="autotoc_md71"></a>
<code>TEST_MESSAGE(message)</code></h3>
<p>This can be useful for outputting <code>INFO</code> messages into the Unity output stream without actually ending the test. Like pass and fail messages, it will be output with the filename and line number.</p>
<h2><a class="anchor" id="autotoc_md72"></a>
Boolean</h2>
<h3><a class="anchor" id="autotoc_md73"></a>
<code>TEST_ASSERT (condition)</code></h3>
<h3><a class="anchor" id="autotoc_md74"></a>
<code>TEST_ASSERT_TRUE (condition)</code></h3>
<h3><a class="anchor" id="autotoc_md75"></a>
<code>TEST_ASSERT_FALSE (condition)</code></h3>
<h3><a class="anchor" id="autotoc_md76"></a>
<code>TEST_ASSERT_UNLESS (condition)</code></h3>
<p>A simple wording variation on <code>TEST_ASSERT_FALSE</code>.The semantics of <code>TEST_ASSERT_UNLESS</code> aid readability in certain test constructions or conditional statements.</p>
<h3><a class="anchor" id="autotoc_md77"></a>
<code>TEST_ASSERT_NULL (pointer)</code></h3>
<h3><a class="anchor" id="autotoc_md78"></a>
<code>TEST_ASSERT_NOT_NULL (pointer)</code></h3>
<p>Verify if a pointer is or is not NULL.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
<code>TEST_ASSERT_EMPTY (pointer)</code></h3>
<h3><a class="anchor" id="autotoc_md80"></a>
<code>TEST_ASSERT_NOT_EMPTY (pointer)</code></h3>
<p>Verify if the first element dereferenced from a pointer is or is not zero. This is particularly useful for checking for empty (or non-empty) null-terminated C strings, but can be just as easily used for other null-terminated arrays.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
Signed and Unsigned Integers (of all sizes)</h2>
<p>Large integer sizes can be disabled for build targets that do not support them. For example, if your target only supports up to 16 bit types, by defining the appropriate symbols Unity can be configured to omit 32 and 64 bit operations that would break compilation (see Unity documentation for more). Refer to Advanced Asserting later in this document for advice on dealing with other word sizes.</p>
<h3><a class="anchor" id="autotoc_md82"></a>
<code>TEST_ASSERT_EQUAL_INT (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md83"></a>
<code>TEST_ASSERT_EQUAL_INT8 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md84"></a>
<code>TEST_ASSERT_EQUAL_INT16 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md85"></a>
<code>TEST_ASSERT_EQUAL_INT32 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md86"></a>
<code>TEST_ASSERT_EQUAL_INT64 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md87"></a>
<code>TEST_ASSERT_EQUAL_UINT (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md88"></a>
<code>TEST_ASSERT_EQUAL_UINT8 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md89"></a>
<code>TEST_ASSERT_EQUAL_UINT16 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md90"></a>
<code>TEST_ASSERT_EQUAL_UINT32 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md91"></a>
<code>TEST_ASSERT_EQUAL_UINT64 (expected, actual)</code></h3>
<h2><a class="anchor" id="autotoc_md92"></a>
Unsigned Integers (of all sizes) in Hexadecimal</h2>
<p>All <code>_HEX</code> assertions are identical in function to unsigned integer assertions but produce failure messages with the <code>expected</code> and <code>actual</code> values formatted in hexadecimal. Unity output is big endian.</p>
<h3><a class="anchor" id="autotoc_md93"></a>
<code>TEST_ASSERT_EQUAL_HEX (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md94"></a>
<code>TEST_ASSERT_EQUAL_HEX8 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md95"></a>
<code>TEST_ASSERT_EQUAL_HEX16 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md96"></a>
<code>TEST_ASSERT_EQUAL_HEX32 (expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md97"></a>
<code>TEST_ASSERT_EQUAL_HEX64 (expected, actual)</code></h3>
<h2><a class="anchor" id="autotoc_md98"></a>
Characters</h2>
<p>While you can use the 8-bit integer assertions to compare <code>char</code>, another option is to use this specialized assertion which will show printable characters as printables, otherwise showing the HEX escape code for the characters.</p>
<h3><a class="anchor" id="autotoc_md99"></a>
<code>TEST_ASSERT_EQUAL_CHAR (expected, actual)</code></h3>
<h2><a class="anchor" id="autotoc_md100"></a>
Masked and Bit-level Assertions</h2>
<p>Masked and bit-level assertions produce output formatted in hexadecimal. Unity output is big endian.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
<code>TEST_ASSERT_BITS (mask, expected, actual)</code></h3>
<p>Only compares the masked (i.e. high) bits of <code>expected</code> and <code>actual</code> parameters.</p>
<h3><a class="anchor" id="autotoc_md102"></a>
<code>TEST_ASSERT_BITS_HIGH (mask, actual)</code></h3>
<p>Asserts the masked bits of the <code>actual</code> parameter are high.</p>
<h3><a class="anchor" id="autotoc_md103"></a>
<code>TEST_ASSERT_BITS_LOW (mask, actual)</code></h3>
<p>Asserts the masked bits of the <code>actual</code> parameter are low.</p>
<h3><a class="anchor" id="autotoc_md104"></a>
<code>TEST_ASSERT_BIT_HIGH (bit, actual)</code></h3>
<p>Asserts the specified bit of the <code>actual</code> parameter is high.</p>
<h3><a class="anchor" id="autotoc_md105"></a>
<code>TEST_ASSERT_BIT_LOW (bit, actual)</code></h3>
<p>Asserts the specified bit of the <code>actual</code> parameter is low.</p>
<h2><a class="anchor" id="autotoc_md106"></a>
Integer Less Than / Greater Than</h2>
<p>These assertions verify that the <code>actual</code> parameter is less than or greater than <code>threshold</code> (exclusive). For example, if the threshold value is 0 for the greater than assertion will fail if it is 0 or less. There are assertions for all the various sizes of ints, as for the equality assertions. Some examples:</p>
<h3><a class="anchor" id="autotoc_md107"></a>
<code>TEST_ASSERT_GREATER_THAN_INT8 (threshold, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md108"></a>
<code>TEST_ASSERT_GREATER_OR_EQUAL_INT16 (threshold, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md109"></a>
<code>TEST_ASSERT_LESS_THAN_INT32 (threshold, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md110"></a>
<code>TEST_ASSERT_LESS_OR_EQUAL_UINT (threshold, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md111"></a>
<code>TEST_ASSERT_NOT_EQUAL_UINT8 (threshold, actual)</code></h3>
<h2><a class="anchor" id="autotoc_md112"></a>
Integer Ranges (of all sizes)</h2>
<p>These assertions verify that the <code>expected</code> parameter is within +/- <code>delta</code> (inclusive) of the <code>actual</code> parameter. For example, if the expected value is 10 and the delta is 3 then the assertion will fail for any value outside the range of 7 - 13.</p>
<h3><a class="anchor" id="autotoc_md113"></a>
<code>TEST_ASSERT_INT_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md114"></a>
<code>TEST_ASSERT_INT8_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md115"></a>
<code>TEST_ASSERT_INT16_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md116"></a>
<code>TEST_ASSERT_INT32_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md117"></a>
<code>TEST_ASSERT_INT64_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md118"></a>
<code>TEST_ASSERT_UINT_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md119"></a>
<code>TEST_ASSERT_UINT8_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md120"></a>
<code>TEST_ASSERT_UINT16_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md121"></a>
<code>TEST_ASSERT_UINT32_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md122"></a>
<code>TEST_ASSERT_UINT64_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md123"></a>
<code>TEST_ASSERT_HEX_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md124"></a>
<code>TEST_ASSERT_HEX8_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md125"></a>
<code>TEST_ASSERT_HEX16_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md126"></a>
<code>TEST_ASSERT_HEX32_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md127"></a>
<code>TEST_ASSERT_HEX64_WITHIN (delta, expected, actual)</code></h3>
<h3><a class="anchor" id="autotoc_md128"></a>
<code>TEST_ASSERT_CHAR_WITHIN (delta, expected, actual)</code></h3>
<h2><a class="anchor" id="autotoc_md129"></a>
Structs and Strings</h2>
<h3><a class="anchor" id="autotoc_md130"></a>
<code>TEST_ASSERT_EQUAL_PTR (expected, actual)</code></h3>
<p>Asserts that the pointers point to the same memory location.</p>
<h3><a class="anchor" id="autotoc_md131"></a>
<code>TEST_ASSERT_EQUAL_STRING (expected, actual)</code></h3>
<p>Asserts that the null terminated (<code>’\0’</code>)strings are identical. If strings are of different lengths or any portion of the strings before their terminators differ, the assertion fails. Two NULL strings (i.e. zero length) are considered equivalent.</p>
<h3><a class="anchor" id="autotoc_md132"></a>
<code>TEST_ASSERT_EQUAL_MEMORY (expected, actual, len)</code></h3>
<p>Asserts that the contents of the memory specified by the <code>expected</code> and <code>actual</code> pointers is identical. The size of the memory blocks in bytes is specified by the <code>len</code> parameter.</p>
<h2><a class="anchor" id="autotoc_md133"></a>
Arrays</h2>
<p><code>expected</code> and <code>actual</code> parameters are both arrays. <code>num_elements</code> specifies the number of elements in the arrays to compare.</p>
<p><code>_HEX</code> assertions produce failure messages with expected and actual array contents formatted in hexadecimal.</p>
<p>For array of strings comparison behavior, see comments for <code>TEST_ASSERT_EQUAL_STRING</code> in the preceding section.</p>
<p>Assertions fail upon the first element in the compared arrays found not to match. Failure messages specify the array index of the failed comparison.</p>
<h3><a class="anchor" id="autotoc_md134"></a>
<code>TEST_ASSERT_EQUAL_INT_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md135"></a>
<code>TEST_ASSERT_EQUAL_INT8_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md136"></a>
<code>TEST_ASSERT_EQUAL_INT16_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md137"></a>
<code>TEST_ASSERT_EQUAL_INT32_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md138"></a>
<code>TEST_ASSERT_EQUAL_INT64_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md139"></a>
<code>TEST_ASSERT_EQUAL_UINT_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md140"></a>
<code>TEST_ASSERT_EQUAL_UINT8_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md141"></a>
<code>TEST_ASSERT_EQUAL_UINT16_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md142"></a>
<code>TEST_ASSERT_EQUAL_UINT32_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md143"></a>
<code>TEST_ASSERT_EQUAL_UINT64_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md144"></a>
<code>TEST_ASSERT_EQUAL_HEX_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md145"></a>
<code>TEST_ASSERT_EQUAL_HEX8_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md146"></a>
<code>TEST_ASSERT_EQUAL_HEX16_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md147"></a>
<code>TEST_ASSERT_EQUAL_HEX32_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md148"></a>
<code>TEST_ASSERT_EQUAL_HEX64_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md149"></a>
<code>TEST_ASSERT_EQUAL_CHAR_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md150"></a>
<code>TEST_ASSERT_EQUAL_PTR_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md151"></a>
<code>TEST_ASSERT_EQUAL_STRING_ARRAY (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md152"></a>
<code>TEST_ASSERT_EQUAL_MEMORY_ARRAY (expected, actual, len, num_elements)</code></h3>
<p><code>len</code> is the memory in bytes to be compared at each array element.</p>
<h2><a class="anchor" id="autotoc_md153"></a>
Integer Array Ranges (of all sizes)</h2>
<p>These assertions verify that the <code>expected</code> array parameter is within +/- <code>delta</code> (inclusive) of the <code>actual</code> array parameter. For example, if the expected value is [10, 12] and the delta is 3 then the assertion will fail for any value outside the range of [7 - 13, 9 - 15].</p>
<h3><a class="anchor" id="autotoc_md154"></a>
<code>TEST_ASSERT_INT_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md155"></a>
<code>TEST_ASSERT_INT8_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md156"></a>
<code>TEST_ASSERT_INT16_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md157"></a>
<code>TEST_ASSERT_INT32_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md158"></a>
<code>TEST_ASSERT_INT64_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md159"></a>
<code>TEST_ASSERT_UINT_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md160"></a>
<code>TEST_ASSERT_UINT8_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md161"></a>
<code>TEST_ASSERT_UINT16_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md162"></a>
<code>TEST_ASSERT_UINT32_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md163"></a>
<code>TEST_ASSERT_UINT64_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md164"></a>
<code>TEST_ASSERT_HEX_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md165"></a>
<code>TEST_ASSERT_HEX8_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md166"></a>
<code>TEST_ASSERT_HEX16_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md167"></a>
<code>TEST_ASSERT_HEX32_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md168"></a>
<code>TEST_ASSERT_HEX64_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md169"></a>
<code>TEST_ASSERT_CHAR_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<h2><a class="anchor" id="autotoc_md170"></a>
Each Equal (Arrays to Single Value)</h2>
<p><code>expected</code> are single values and <code>actual</code> are arrays. <code>num_elements</code> specifies the number of elements in the arrays to compare.</p>
<p><code>_HEX</code> assertions produce failure messages with expected and actual array contents formatted in hexadecimal.</p>
<p>Assertions fail upon the first element in the compared arrays found not to match. Failure messages specify the array index of the failed comparison.</p>
<h3><a class="anchor" id="autotoc_md171"></a>
<code>TEST_ASSERT_EACH_EQUAL_INT (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md172"></a>
<code>TEST_ASSERT_EACH_EQUAL_INT8 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md173"></a>
<code>TEST_ASSERT_EACH_EQUAL_INT16 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md174"></a>
<code>TEST_ASSERT_EACH_EQUAL_INT32 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md175"></a>
<code>TEST_ASSERT_EACH_EQUAL_INT64 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md176"></a>
<code>TEST_ASSERT_EACH_EQUAL_UINT (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md177"></a>
<code>TEST_ASSERT_EACH_EQUAL_UINT8 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md178"></a>
<code>TEST_ASSERT_EACH_EQUAL_UINT16 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md179"></a>
<code>TEST_ASSERT_EACH_EQUAL_UINT32 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md180"></a>
<code>TEST_ASSERT_EACH_EQUAL_UINT64 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md181"></a>
<code>TEST_ASSERT_EACH_EQUAL_HEX (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md182"></a>
<code>TEST_ASSERT_EACH_EQUAL_HEX8 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md183"></a>
<code>TEST_ASSERT_EACH_EQUAL_HEX16 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md184"></a>
<code>TEST_ASSERT_EACH_EQUAL_HEX32 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md185"></a>
<code>TEST_ASSERT_EACH_EQUAL_HEX64 (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md186"></a>
<code>TEST_ASSERT_EACH_EQUAL_CHAR (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md187"></a>
<code>TEST_ASSERT_EACH_EQUAL_PTR (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md188"></a>
<code>TEST_ASSERT_EACH_EQUAL_STRING (expected, actual, num_elements)</code></h3>
<h3><a class="anchor" id="autotoc_md189"></a>
<code>TEST_ASSERT_EACH_EQUAL_MEMORY (expected, actual, len, num_elements)</code></h3>
<p><code>len</code> is the memory in bytes to be compared at each array element.</p>
<h2><a class="anchor" id="autotoc_md190"></a>
Floating Point (If enabled)</h2>
<h3><a class="anchor" id="autotoc_md191"></a>
<code>TEST_ASSERT_FLOAT_WITHIN (delta, expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is within +/- <code>delta</code> of the <code>expected</code> value. The nature of floating point representation is such that exact evaluations of equality are not guaranteed.</p>
<h3><a class="anchor" id="autotoc_md192"></a>
<code>TEST_ASSERT_FLOAT_NOT_WITHIN (delta, expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is NOT within +/- <code>delta</code> of the <code>expected</code> value.</p>
<h3><a class="anchor" id="autotoc_md193"></a>
<code>TEST_ASSERT_EQUAL_FLOAT (expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is “close enough to be considered equal” to the <code>expected</code> value. If you are curious about the details, refer to the Advanced Asserting section for more details on this. Omitting a user-specified delta in a floating point assertion is both a shorthand convenience and a requirement of code generation conventions for CMock.</p>
<h3><a class="anchor" id="autotoc_md194"></a>
<code>TEST_ASSERT_NOT_EQUAL_FLOAT (expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is NOT “close enough to be considered equal” to the <code>expected</code> value.</p>
<h3><a class="anchor" id="autotoc_md195"></a>
<code>TEST_ASSERT_FLOAT_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<p>See Array assertion section for details. Note that individual array element uses user-provided delta plus default comparison delta for checking and is based on <code>TEST_ASSERT_FLOAT_WITHIN</code> comparison.</p>
<h3><a class="anchor" id="autotoc_md196"></a>
<code>TEST_ASSERT_EQUAL_FLOAT_ARRAY (expected, actual, num_elements)</code></h3>
<p>See Array assertion section for details. Note that individual array element float comparisons are executed using <code>TEST_ASSERT_EQUAL_FLOAT</code>. That is, user specified delta comparison values requires a custom-implemented floating point array assertion.</p>
<h3><a class="anchor" id="autotoc_md197"></a>
<code>TEST_ASSERT_LESS_THAN_FLOAT (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is less than <code>threshold</code> (exclusive). For example, if the threshold value is 1.0f, the assertion will fail if it is greater than 1.0f.</p>
<h3><a class="anchor" id="autotoc_md198"></a>
<code>TEST_ASSERT_GREATER_THAN_FLOAT (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is greater than <code>threshold</code> (exclusive). For example, if the threshold value is 1.0f, the assertion will fail if it is less than 1.0f.</p>
<h3><a class="anchor" id="autotoc_md199"></a>
<code>TEST_ASSERT_LESS_OR_EQUAL_FLOAT (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is less than or equal to <code>threshold</code>. The rules for equality are the same as for <code>TEST_ASSERT_EQUAL_FLOAT</code>.</p>
<h3><a class="anchor" id="autotoc_md200"></a>
<code>TEST_ASSERT_GREATER_OR_EQUAL_FLOAT (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is greater than <code>threshold</code>. The rules for equality are the same as for <code>TEST_ASSERT_EQUAL_FLOAT</code>.</p>
<h3><a class="anchor" id="autotoc_md201"></a>
<code>TEST_ASSERT_FLOAT_IS_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is equivalent to positive infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md202"></a>
<code>TEST_ASSERT_FLOAT_IS_NEG_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is equivalent to negative infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md203"></a>
<code>TEST_ASSERT_FLOAT_IS_NAN (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a Not A Number floating point representation.</p>
<h3><a class="anchor" id="autotoc_md204"></a>
<code>TEST_ASSERT_FLOAT_IS_DETERMINATE (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a floating point representation usable for mathematical operations. That is, the <code>actual</code> parameter is neither positive infinity nor negative infinity nor Not A Number floating point representations.</p>
<h3><a class="anchor" id="autotoc_md205"></a>
<code>TEST_ASSERT_FLOAT_IS_NOT_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than positive infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md206"></a>
<code>TEST_ASSERT_FLOAT_IS_NOT_NEG_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than negative infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md207"></a>
<code>TEST_ASSERT_FLOAT_IS_NOT_NAN (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than Not A Number floating point representation.</p>
<h3><a class="anchor" id="autotoc_md208"></a>
<code>TEST_ASSERT_FLOAT_IS_NOT_DETERMINATE (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is not usable for mathematical operations. That is, the <code>actual</code> parameter is either positive infinity or negative infinity or Not A Number floating point representations.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
Double (If enabled)</h2>
<h3><a class="anchor" id="autotoc_md210"></a>
<code>TEST_ASSERT_DOUBLE_WITHIN (delta, expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is within +/- <code>delta</code> of the <code>expected</code> value. The nature of floating point representation is such that exact evaluations of equality are not guaranteed.</p>
<h3><a class="anchor" id="autotoc_md211"></a>
<code>TEST_ASSERT_DOUBLE_NOT_WITHIN (delta, expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is NOT within +/- <code>delta</code> of the <code>expected</code> value.</p>
<h3><a class="anchor" id="autotoc_md212"></a>
<code>TEST_ASSERT_EQUAL_DOUBLE (expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is “close enough to be considered equal” to the <code>expected</code> value. If you are curious about the details, refer to the Advanced Asserting section for more details. Omitting a user-specified delta in a floating point assertion is both a shorthand convenience and a requirement of code generation conventions for CMock.</p>
<h3><a class="anchor" id="autotoc_md213"></a>
<code>TEST_ASSERT_NOT_EQUAL_DOUBLE (expected, actual)</code></h3>
<p>Asserts that the <code>actual</code> value is NOT “close enough to be considered equal” to the <code>expected</code> value.</p>
<h3><a class="anchor" id="autotoc_md214"></a>
<code>TEST_ASSERT_DOUBLE_ARRAY_WITHIN (delta, expected, actual, num_elements)</code></h3>
<p>See Array assertion section for details. Note that individual array element uses user-provided delta plus default comparison delta for checking and is based on <code>TEST_ASSERT_DOUBLE_WITHIN</code> comparison.</p>
<h3><a class="anchor" id="autotoc_md215"></a>
<code>TEST_ASSERT_EQUAL_DOUBLE_ARRAY (expected, actual, num_elements)</code></h3>
<p>See Array assertion section for details. Note that individual array element double comparisons are executed using <code>TEST_ASSERT_EQUAL_DOUBLE</code>. That is, user specified delta comparison values requires a custom implemented double array assertion.</p>
<h3><a class="anchor" id="autotoc_md216"></a>
<code>TEST_ASSERT_LESS_THAN_DOUBLE (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is less than <code>threshold</code> (exclusive). For example, if the threshold value is 1.0, the assertion will fail if it is greater than 1.0.</p>
<h3><a class="anchor" id="autotoc_md217"></a>
<code>TEST_ASSERT_LESS_OR_EQUAL_DOUBLE (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is less than or equal to <code>threshold</code>. The rules for equality are the same as for <code>TEST_ASSERT_EQUAL_DOUBLE</code>.</p>
<h3><a class="anchor" id="autotoc_md218"></a>
<code>TEST_ASSERT_GREATER_THAN_DOUBLE (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is greater than <code>threshold</code> (exclusive). For example, if the threshold value is 1.0, the assertion will fail if it is less than 1.0.</p>
<h3><a class="anchor" id="autotoc_md219"></a>
<code>TEST_ASSERT_GREATER_OR_EQUAL_DOUBLE (threshold, actual)</code></h3>
<p>Asserts that the <code>actual</code> parameter is greater than or equal to <code>threshold</code>. The rules for equality are the same as for <code>TEST_ASSERT_EQUAL_DOUBLE</code>.</p>
<h3><a class="anchor" id="autotoc_md220"></a>
<code>TEST_ASSERT_DOUBLE_IS_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is equivalent to positive infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md221"></a>
<code>TEST_ASSERT_DOUBLE_IS_NEG_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is equivalent to negative infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md222"></a>
<code>TEST_ASSERT_DOUBLE_IS_NAN (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a Not A Number floating point representation.</p>
<h3><a class="anchor" id="autotoc_md223"></a>
<code>TEST_ASSERT_DOUBLE_IS_DETERMINATE (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a floating point representation usable for mathematical operations. That is, the <code>actual</code> parameter is neither positive infinity nor negative infinity nor Not A Number floating point representations.</p>
<h3><a class="anchor" id="autotoc_md224"></a>
<code>TEST_ASSERT_DOUBLE_IS_NOT_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than positive infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md225"></a>
<code>TEST_ASSERT_DOUBLE_IS_NOT_NEG_INF (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than negative infinity floating point representation.</p>
<h3><a class="anchor" id="autotoc_md226"></a>
<code>TEST_ASSERT_DOUBLE_IS_NOT_NAN (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is a value other than Not A Number floating point representation.</p>
<h3><a class="anchor" id="autotoc_md227"></a>
<code>TEST_ASSERT_DOUBLE_IS_NOT_DETERMINATE (actual)</code></h3>
<p>Asserts that <code>actual</code> parameter is not usable for mathematical operations. That is, the <code>actual</code> parameter is either positive infinity or negative infinity or Not A Number floating point representations.</p>
<h1><a class="anchor" id="autotoc_md228"></a>
Advanced Asserting: Details On Tricky Assertions</h1>
<p>This section helps you understand how to deal with some of the trickier assertion situations you may run into. It will give you a glimpse into some of the under-the-hood details of Unity’s assertion mechanisms. If you’re one of those people who likes to know what is going on in the background, read on. If not, feel free to ignore the rest of this document until you need it.</p>
<h2><a class="anchor" id="autotoc_md229"></a>
How do the EQUAL assertions work for FLOAT and DOUBLE?</h2>
<p>As you may know, directly checking for equality between a pair of floats or a pair of doubles is sloppy at best and an outright no-no at worst. Floating point values can often be represented in multiple ways, particularly after a series of operations on a value. Initializing a variable to the value of 2.0 is likely to result in a floating point representation of 2 x 20,but a series of mathematical operations might result in a representation of 8 x 2-2 that also evaluates to a value of 2. At some point repeated operations cause equality checks to fail.</p>
<p>So Unity doesn’t do direct floating point comparisons for equality. Instead, it checks if two floating point values are “really close.” If you leave Unity running with defaults, “really close” means “within a significant bit or two.” Under the hood, <code>TEST_ASSERT_EQUAL_FLOAT</code> is really <code>TEST_ASSERT_FLOAT_WITHIN</code> with the <code>delta</code> parameter calculated on the fly. For single precision, delta is the expected value multiplied by 0.00001, producing a very small proportional range around the expected value.</p>
<p>If you are expecting a value of 20,000.0 the delta is calculated to be 0.2. So any value between 19,999.8 and 20,000.2 will satisfy the equality check. This works out to be roughly a single bit of range for a single-precision number, and that’s just about as tight a tolerance as you can reasonably get from a floating point value.</p>
<p>So what happens when it’s zero? Zero - even more than other floating point values - can be represented many different ways. It doesn’t matter if you have 0x20 or 0x263. It’s still zero, right? Luckily, if you subtract these values from each other, they will always produce a difference of zero, which will still fall between 0 plus or minus a delta of 0. So it still works!</p>
<p>Double precision floating point numbers use a much smaller multiplier, again approximating a single bit of error.</p>
<p>If you don’t like these ranges and you want to make your floating point equality assertions less strict, you can change these multipliers to whatever you like by defining UNITY_FLOAT_PRECISION and UNITY_DOUBLE_PRECISION. See Unity documentation for more.</p>
<h2><a class="anchor" id="autotoc_md230"></a>
How do we deal with targets with non-standard int sizes?</h2>
<p>It’s “fun” that C is a standard where something as fundamental as an integer varies by target. According to the C standard, an <code>int</code> is to be the target’s natural register size, and it should be at least 16-bits and a multiple of a byte. It also guarantees an order of sizes:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> &lt;= <span class="keywordtype">short</span> &lt;= <span class="keywordtype">int</span> &lt;= <span class="keywordtype">long</span> &lt;= <span class="keywordtype">long</span> <span class="keywordtype">long</span></div>
</div><!-- fragment --><p>Most often, <code>int</code> is 32-bits. In many cases in the embedded world, <code>int</code> is 16-bits. There are rare microcontrollers out there that have 24-bit integers, and this remains perfectly standard C.</p>
<p>To make things even more interesting, there are compilers and targets out there that have a hard choice to make. What if their natural register size is 10-bits or 12-bits? Clearly they can’t fulfill <em>both</em> the requirement to be at least 16-bits AND the requirement to match the natural register size. In these situations, they often choose the natural register size, leaving us with something like this:</p>
<div class="fragment"><div class="line">char (8 bit) &lt;= short (12 bit) &lt;= int (12 bit) &lt;= long (16 bit)</div>
</div><!-- fragment --><p>Um… yikes. It’s obviously breaking a rule or two… but they had to break SOME rules, so they made a choice.</p>
<p>When the C99 standard rolled around, it introduced alternate standard-size types. It also introduced macros for pulling in MIN/MAX values for your integer types. It’s glorious! Unfortunately, many embedded compilers can’t be relied upon to use the C99 types (Sometimes because they have weird register sizes as described above. Sometimes because they don’t feel like it?).</p>
<p>A goal of Unity from the beginning was to support every combination of microcontroller or microprocessor and C compiler. Over time, we’ve gotten really close to this. There are a few tricks that you should be aware of, though, if you’re going to do this effectively on some of these more idiosyncratic targets.</p>
<p>First, when setting up Unity for a new target, you’re going to want to pay special attention to the macros for automatically detecting types (where available) or manually configuring them yourself. You can get information on both of these in Unity’s documentation.</p>
<p>What about the times where you suddenly need to deal with something odd, like a 24-bit <code>int</code>? The simplest solution is to use the next size up. If you have a 24-bit <code>int</code>, configure Unity to use 32-bit integers. If you have a 12-bit <code>int</code>, configure Unity to use 16 bits. There are two ways this is going to affect you:</p>
<ol type="1">
<li>When Unity displays errors for you, it’s going to pad the upper unused bits with zeros.</li>
<li>You’re going to have to be careful of assertions that perform signed operations, particularly <code>TEST_ASSERT_INT_WITHIN</code>. Such assertions might wrap your <code>int</code> in the wrong place, and you could experience false failures. You can always back down to a simple <code>TEST_ASSERT</code> and do the operations yourself.</li>
</ol>
<p><em>Find The Latest of This And More at <a href="https://throwtheswitch.org">ThrowTheSwitch.org</a></em> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
